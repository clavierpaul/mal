#!/bin/bash

# let's do some sorcery to bestow IO upon jq
runjq() {
    pipe_name=$(mktemp)
    rm -f $pipe_name $ipipe_name
    mkfifo $pipe_name || true
    xstdout=$(readlink /proc/self/fd/1)
    stdin=$(readlink /proc/self/fd/0)
    trap "rm -f $pipe_name" EXIT SIGINT SIGHUP
    (
        while [[ -e $pipe_name ]]; do
            timeout 1 cat $pipe_name
        done&
    ) | jq -nrRM -f "$(dirname "$0")/${STEP:-stepA_mal}.jq" --args "${@}" |&\
    tee \
        >(jq -Rr 'try fromjson[1]|if type == "string" then . else empty end') \
        >(while read -r line; do
            command=$(echo $line | jq -c 'try if .[1] | has("command") then .[1].command else empty end' 2>/dev/null)
            if [[ $command ]]; then
                # echo ">>> " $command
                cmd=$(echo "$command" | jq -rMc 'try .cmd catch "ignore"')
                case "$cmd" in
                readline)
                    data=$(jq -nR input < $stdin)
                    size=${#data}
                    # echo "read $size bytes '$data'"
                    echo "$data" | pv -q -B $size > $pipe_name
                ;;
                read)
                    filename=$(echo "$command" | jq -Mrc '.args[0]')
                    tmp=$(mktemp)
                    # echo "Read $filename into $tmp"
                    jq -rRnc --rawfile content "$filename" '$content|tojson' > $tmp
                    # echo "dump $tmp to pipe"
                    size=$(du -k $tmp)
                    cat $tmp | pv -q -B $size > $pipe_name #>/dev/null 2>&1
                    rm $tmp
                ;;
                fwrite)
                    tmp=$(mktemp)
                    echo "$command" > $tmp
                    filename=$(cat $tmp | jq -Mrc ".args[0]|fromjson")
                    content=$(cat $tmp | jq -Mrc ".args[1]|fromjson")
                    app=$(cat $tmp | jq -Mrc ".args[2]|fromjson")
                    echo "'$app': Writing stuff to $filename"
                    if [[ $res == false ]]; then
                        echo "$content" > "$filename"
                    else
                        echo "$content" >> "$filename"
                    fi
                ;;
                *)
                    echo $cmd
                ;;
                esac
            fi
        done) > /dev/null
    rm -f $pipe_name
}
my_pid=$$
trap 'kill -INT $my_pid' EXIT SIGINT
runjq "${@}"