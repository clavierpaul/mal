(module $util
  (import "env" "malloc" (func $malloc (param i32) (result i32)))
  (import "env" "free" (func $free (param i32)))
  (import "env" "exit" (func $exit (param i32)))

  (import "env" "stdout" (global $stdout i32))
  (import "env" "fputs" (func $fputs (param i32 i32) (result i32)))
  ;;(import "env" "readline" (func $readline (param i32) (result i32)))
  (import "libedit.so" "readline" (func $readline (param i32) (result i32)))
  ;;(import "libreadline.so" "readline" (func $readline (param i32) (result i32)))

  (global $util_buf (mut i32) 0)

  ;; read_file defintions / FFI information
  (global $STAT_SIZE i32 88)
  (global $STAT_ST_SIZE_OFFSET i32 44)
  (global $STAT_VER_LINUX i32 3)
  (global $O_RDONLY i32 0)
  (import "env" "open" (func $open (param i32 i32 i32) (result i32)))
  (import "env" "read" (func $read (param i32 i32 i32) (result i32)))
  (import "env" "__fxstat" (func $__fxstat (param i32 i32 i32) (result i32)))
  (global $TIMEVAL_SIZE i32 8)
  (global $TV_SEC_OFFSET i32 0)
  (global $TV_USEC_OFFSET i32 4)
  (import "env" "gettimeofday" (func $gettimeofday (param i32 i32) (result i32)))

  (func $init_sprintf_mem
    ;; sprintf static buffer
    (set_global $util_buf (STATIC_ARRAY 256))
    )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (func $print (param $addr i32)
    (drop ($fputs $addr (get_global $stdout))))

  (func $printf_1 (param $fmt i32) (param $v0 i32)
    (drop ($sprintf_6 (get_global $util_buf) $fmt $v0 0 0 0 0 0))
    ($print (get_global $util_buf))
  )

  (func $printf_2 (param $fmt i32 $v0 i32 $v1 i32)
    (drop ($sprintf_6 (get_global $util_buf) $fmt $v0 $v1 0 0 0 0))
    ($print (get_global $util_buf))
  )

  (func $printf_3 (param $fmt i32)
        (param $v0 i32) (param $v1 i32) (param $v2 i32)
    (drop ($sprintf_6 (get_global $util_buf) $fmt $v0 $v1 $v2 0 0 0))
    ($print (get_global $util_buf))
  )

  (func $printf_4 (param $fmt i32)
        (param $v0 i32) (param $v1 i32) (param $v2 i32)
        (param $v3 i32)
    (drop ($sprintf_6 (get_global $util_buf) $fmt $v0 $v1 $v2 $v3 0 0))
    ($print (get_global $util_buf))
  )

  (func $printf_5 (param $fmt i32)
        (param $v0 i32) (param $v1 i32) (param $v2 i32)
        (param $v3 i32) (param $v4 i32)
    (drop ($sprintf_6 (get_global $util_buf) $fmt $v0 $v1 $v2 $v3 $v4 0))
    ($print (get_global $util_buf))
  )

  (func $printf_6 (param $fmt i32)
        (param $v0 i32) (param $v1 i32) (param $v2 i32)
        (param $v3 i32) (param $v4 i32) (param $v5 i32)
    (drop ($sprintf_6 (get_global $util_buf) $fmt $v0 $v1 $v2 $v3 $v4 $v5))
    ($print (get_global $util_buf))
  )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (func $_sprintdigit (param $str i32) (param $num i32) (param $base i32)
    (local $n i32 $ch i32)
    (set_local $n (i32.rem_u $num $base))
    (set_local $ch (if (result i32) (i32.lt_u $n 10) 48 55))
    (i32.store8_u $str (i32.add $n $ch))
  )

  ;; TODO: add max buf length (i.e. snprintnum)
  (func $_sprintnum (param $buf i32) (param $val i32) (param $radix i32)
        (param $pad_cnt i32) (param $pad_char i32) (result i32)
    (local $pbuf i32 $i i32 $j i32 $k i32 $len i32 $neg i32 $digit i32)
    (set_local $pbuf $buf)
    (set_local $neg 0)

    (if (AND (i32.lt_s $val 0) (i32.eq $radix 10))
      (then
        (set_local $neg 1)
        (set_local $val (i32.sub_s 0 $val))))

    ;; Calculate smallest to most significant digit
    (loop $loop
      (set_local $digit (i32.rem_u $val $radix))
      (i32.store8_u $pbuf (if i32 (i32.lt_s $digit 10)
                            (i32.add (CHR "0") $digit)
                            (i32.sub_s (i32.add (CHR "A") $digit) 10)))
      (set_local $pbuf (i32.add $pbuf 1))
      (set_local $val (i32.div_s $val $radix))
      (if (i32.gt_s $val 0) (br $loop))
    )

    (set_local $i (i32.sub_s $pbuf $buf))
    (block $done
      (loop $loop
        (if (i32.ge_s $i $pad_cnt) (br $done))
        (i32.store8_u $pbuf $pad_char)
        (set_local $pbuf (i32.add $pbuf 1))
        (set_local $i (i32.add $i 1))
        (br $loop)
      )
    )

    (if $neg
      (then
        (i32.store8_u $pbuf (CHR "-"))
        (set_local $pbuf (i32.add $pbuf 1))))

    (i32.store8_u $pbuf (CHR "\x00"))

    ;; now reverse it
    (set_local $len (i32.sub_s $pbuf $buf))
    (set_local $i 0)
    (block $done
      (loop $loop
        (if (i32.ge_s $i (i32.div_s $len 2))
          (br $done))

        (set_local $j (i32.load8_u (i32.add $buf $i)))
        (set_local $k (i32.add $buf (i32.sub_s (i32.sub_s $len $i) 1)))
        (i32.store8_u (i32.add $buf $i) (i32.load8_u $k))
        (i32.store8_u $k $j)
        (set_local $i (i32.add $i 1))
        (br $loop)
      )
    )

    (i32.add $buf $len)
  )

  ;; TODO: switch to snprint* (add buffer len)
  (func $sprintf_1 (param $str i32) (param $fmt i32)
        (param $v0 i32) (result i32)
    ($sprintf_6 $str $fmt $v0 0 0 0 0 0)
  )

  (func $sprintf_6 (param $str i32) (param $fmt i32)
        (param $v0 i32) (param $v1 i32) (param $v2 i32)
        (param $v3 i32) (param $v4 i32) (param $v5 i32)
        (result i32)
    (local $ch i32 $pstr i32 $v i32 $vidx i32 $len i32)
    (local $pad_cnt i32 $pad_char i32)
    (set_local $pstr $str)
    (set_local $vidx 0)

    (block $done
      (loop $loop
        (block $after_v
          ;; set $v to the current parameter
          (block (block (block (block (block (block
          (br_table 0 1 2 3 4 5 0 $vidx))
          (; 0 ;) (set_local $v $v0) (br $after_v))
          (; 1 ;) (set_local $v $v1) (br $after_v))
          (; 2 ;) (set_local $v $v2) (br $after_v))
          (; 3 ;) (set_local $v $v3) (br $after_v))
          (; 4 ;) (set_local $v $v4) (br $after_v))
          (; 5 ;) (set_local $v $v5) (br $after_v)
        )

        ;;; while ((ch=*(fmt++)))
        (set_local $ch (i32.load8_u $fmt))
        (set_local $fmt (i32.add 1 $fmt))
        (if (i32.eqz $ch) (br $done))
        ;; TODO: check buffer length

        (if (i32.ne $ch (CHR "%"))
          (then
            ;; TODO: check buffer length
            (i32.store8_u $pstr $ch)
            (set_local $pstr (i32.add 1 $pstr))
            (br $loop)))

        ;;; ch=*(fmt++)
        (set_local $ch (i32.load8_u $fmt))
        (set_local $fmt (i32.add 1 $fmt))
        (if (i32.eqz $ch) (br $done))

        (set_local $pad_cnt 0)
        (set_local $pad_char (CHR " "))
        (if (AND (i32.ge_s $ch (CHR "0")) (i32.le_s $ch (CHR "9")))
          (then
            ;; padding requested
            (if (i32.eq $ch (CHR "0"))
              (then
                ;; zero padding requested
                (set_local $pad_char (CHR "0"))
                ;;; ch=*(fmt++)
                (set_local $ch (i32.load8_u $fmt))
                (set_local $fmt (i32.add 1 $fmt))
                (if (i32.eqz $ch) (br $done))))
            (loop $loop
              (set_local $pad_cnt (i32.mul_s $pad_cnt 10))
              (set_local $pad_cnt (i32.add $pad_cnt
                                           (i32.sub_s $ch (CHR "0"))))
              (set_local $ch (i32.load8_u $fmt))
              (set_local $fmt (i32.add 1 $fmt))
              (if (AND (i32.ge_s $ch (CHR "0")) (i32.le_s $ch (CHR "9")))
                (br $loop))
            )))

        (if (i32.eq (CHR "d") $ch)
          (then
            (set_local $pstr ($_sprintnum $pstr $v 10 $pad_cnt $pad_char)))
        (else (if (i32.eq (CHR "x") $ch)
          (then
            (set_local $pstr ($_sprintnum $pstr $v 16 $pad_cnt $pad_char)))
        (else (if (i32.eq (CHR "s") $ch)
          (then
            (set_local $len ($strlen $v))
            (block $done
              (loop $loop
                (if (i32.le_s $pad_cnt $len)
                  (br $done))
                (i32.store8_u $pstr (CHR " "))
                (set_local $pstr (i32.add $pstr 1))
                (set_local $pad_cnt (i32.sub_s $pad_cnt 1))
                (br $loop)
              )
            )
            ($memmove $pstr $v $len)
            (set_local $pstr (i32.add $pstr $len)))
        (else (if (i32.eq (CHR "c") $ch)
          (then
            (i32.store8_u $pstr $v)
            (set_local $pstr (i32.add $pstr 1)))
        (else (if (i32.eq (CHR "%") $ch)
          (then
            (i32.store8_u $pstr (CHR "%"))
            (set_local $pstr (i32.add $pstr 1))
            (br $loop)) ;; don't increase vidx
        (else
          ($printf_1 "Illegal format character: '%c'\n" $ch)
          ($exit 3)))))))))))

        (set_local $vidx (i32.add 1 $vidx))
        (br $loop)
      )
    )

    (i32.store8_u $pstr (CHR "\x00"))
    $pstr
  )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Returns malloc'd string. Must be free by caller
  (func $read_file (param $path i32) (result i32)
    (local $fst i32 $fd i32 $str i32 $st_size i32 $sz i32)
    (set_local $str 0)
    (set_local $fst ($malloc (get_global $STAT_SIZE)))
    (if (i32.le_s $fst 0)
      (then
        ($printf_1 "ERROR: malloc of %d bytes failed\n"
                   (get_global $STAT_SIZE))
        (return 0)))

    (block $free_fst
      (set_local $fd ($open $path (get_global $O_RDONLY) 0))
      (if (i32.lt_s $fd 0)
        (then
          ($printf_1 "ERROR: slurp failed to open '%s'\n" $path)
          (br $free_fst)))
      (if (i32.lt_s ($__fxstat (get_global $STAT_VER_LINUX) $fd $fst) 0)
        (then
          ($printf_1 "ERROR: slurp failed to stat '%s'\n" $path)
          (br $free_fst)))
      (set_local $st_size (i32.load
                            (i32.add $fst (get_global $STAT_ST_SIZE_OFFSET))))
      (set_local $str ($malloc (i32.add 1 $st_size)))
      (if (i32.le_s $str 0)
        (then
          ($printf_1 "ERROR: malloc of %d bytes failed\n" $st_size)
          (br $free_fst)))
      (set_local $sz ($read $fd $str $st_size))
      (if (i32.ne $sz $st_size)
        (then
          ($free $str)
          (set_local $str 0)
          ($printf_1 "ERROR: slurp failed to stat '%s'\n" $path)
          (br $free_fst)))
      ;; Add null to string
      (i32.store8_u (i32.add $str $st_size) 0)
    )
    ($free $fst)
    $str
  )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


  (func $get_time_ms (result i32)
    (local $tv i32 $secs i32 $usecs i32 $msecs i32)
    (set_local $tv ($malloc (get_global $TIMEVAL_SIZE)))
    (drop ($gettimeofday $tv 0))
    (set_local $secs (i32.load (i32.add $tv (get_global $TV_SEC_OFFSET))))
    ;; subtract 30 years to make sure secs is positive and can be
    ;; multiplied by 1000
    (set_local $secs (i32.sub_s $secs 0x38640900))
    (set_local $usecs (i32.load (i32.add $tv (get_global $TV_USEC_OFFSET))))
    (set_local $msecs (i32.add (i32.mul_u $secs 1000)
                               (i32.div_u $usecs 1000)))
    ($free $tv)
    $msecs
  )
)
