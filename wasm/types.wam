;; Mal value memory layout
;;   type           words
;;   ----------     ----------
;;   nil            ref/ 0 |  0           |               |
;;   false          ref/ 1 |  0           |               |
;;   true           ref/ 1 |  1           |               |
;;   integer        ref/ 2 | int          |               |
;;   float          ref/ 3 | ???          |               |
;;   string/kw      ref/ 4 | string ptr   |               |
;;   symbol         ref/ 5 | string ptr   |               |
;;   list           ref/ 6 | next mem idx | val mem idx   |
;;   vector         ref/ 7 | next mem idx | val mem idx   |
;;   hashmap        ref/ 8 | next mem idx | key mem idx   | val mem idx
;;   function       ref/ 9 | fn idx       |               |
;;   mal function   ref/10 | body mem idx | param mem idx | env mem idx
;;   macro fn       ref/11 | body mem idx | param mem idx | env mem idx
;;   atom           ref/12 | val mem idx  |               |
;;   environment    ref/13 | hmap mem idx | outer mem idx |
;;   metadata       ref/14 | obj mem idx  | meta mem idx  |
;;   FREE            sz/15 | next mem idx |               |

(module $types

  (global $NIL_T                  i32 0)
  (global $BOOLEAN_T              i32 1)
  (global $INTEGER_T              i32 2)
  (global $FLOAT_T                i32 3)
  (global $STRING_T               i32 4)
  (global $SYMBOL_T               i32 5)
  (global $LIST_T                 i32 6)
  (global $VECTOR_T               i32 7)
  (global $HASHMAP_T              i32 8)
  (global $FUNCTION_T             i32 9)
  (global $MALFUNC_T              i32 10)
  (global $MACRO_T                i32 11)
  (global $ATOM_T                 i32 12)
  (global $ENVIRONMENT_T          i32 13)
  (global $METADATA_T             i32 14)
  (global $FREE_T                 i32 15)

  (global $error_type             (mut i32) 0)
  (global $error_val              (mut i32) 0)
  ;; Index into static string memory (static.wast)
  (global $error_str              (mut i32) 0)

  (global $NIL                    (mut i32) 0)
  (global $FALSE                  (mut i32) 0)
  (global $TRUE                   (mut i32) 0)
  (global $EMPTY_LIST             (mut i32) 0)
  (global $EMPTY_VECTOR           (mut i32) 0)
  (global $EMPTY_HASHMAP          (mut i32) 0)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; General functions

  (func $INC_REF (param $mv i32) (result i32)
    (i32.store $mv (i32.add (i32.load $mv) 32))
    $mv)

  (func $THROW_STR_0 (param $fmt i32)
    (drop ($sprintf_1 (get_global $error_str) $fmt ""))
    (set_global $error_type 1))

  (func $THROW_STR_1 (param $fmt i32) (param $v0 i32)
    (drop ($sprintf_1 (get_global $error_str) $fmt $v0))
    (set_global $error_type 1))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; numeric functions

  (func $INTEGER (param $val i32) (result i32)
    ($ALLOC_SCALAR (get_global $INTEGER_T) $val))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; sequence functions

  (func $MAP_LOOP_START (param $type i32) (result i32)
    (local $res i32)
    (set_local $res (if i32 (i32.eq $type (get_global $LIST_T))
                      (get_global $EMPTY_LIST)
                    (else (if i32 (i32.eq $type (get_global $VECTOR_T))
                      (get_global $EMPTY_VECTOR)
                    (else (if i32 (i32.eq $type (get_global $HASHMAP_T))
                      (get_global $EMPTY_HASHMAP)
                    (else
                      ($THROW_STR_1 "read_seq invalid type %d" $type)
                      0)))))))

    ($INC_REF $res)
  )

  (func $MAP_LOOP_UPDATE (param $type i32) (param $empty i32)
        (param $current i32) (param $val2 i32) (param $val3 i32)
        (result i32)
    (local $res i32)

    (set_local $res ($ALLOC $type $empty $val2 $val3))
    ;; sequence took ownership
    ($RELEASE $empty)
    ($RELEASE $val2)
    (if (i32.eq $type (get_global $HASHMAP_T))
      ($RELEASE $val3))
    (if (i32.gt_u $current (get_global $EMPTY_HASHMAP))
      ;; if not first element, set current next to point to new element
      (i32.store ($VAL0_ptr $current) ($MalVal_index $res)))

    $res
  )

  (func $EMPTY_Q (param $mv i32) (result i32)
    (i32.eq ($VAL0 $mv) 0)
  )

  (func $HASHMAP (result i32)
    ;; just point to static empty hash-map
    ($INC_REF (get_global $EMPTY_HASHMAP))
  )

  (func $ASSOC1 (param $hm i32) (param $k i32) (param $v i32) (result i32)
    (local $res i32)
    (set_local $res ($ALLOC (get_global $HASHMAP_T) $hm $k $v))
    ;; we took ownership of previous release
    ($RELEASE $hm)
    $res
  )

  (func $ASSOC1_S (param $hm i32) (param $k i32) (param $v i32) (result i32)
    (local $kmv i32)
    (local $res i32)
    (set_local $kmv ($STRING (get_global $STRING_T) $k))
    (set_local $res ($ASSOC1 $hm $kmv $v))
    ;; map took ownership of key
    ($RELEASE $kmv)
    $res
  )

  (func $HASHMAP_GET (param $hm i32) (param $key_mv i32) (result i64)
    (local $res i32)
    (local $found i32)
    (local $key i32)
    (local $test_key_mv i32)

    (set_local $key ($to_String $key_mv))
    (set_local $found 0)


    (block $done
      (loop $loop
        ;;; if (VAL0(hm) == 0)
        (if (i32.eq ($VAL0 $hm) 0)
          (then
            (set_local $res (get_global $NIL))
            (br $done)))
        ;;; test_key_mv = MEM_VAL1(hm)
        (set_local $test_key_mv ($MEM_VAL1_ptr $hm))
        ;;; if (strcmp(key, to_String(test_key_mv)) == 0)
        (if (i32.eq ($strcmp $key ($to_String $test_key_mv)) 0)
          (then
            (set_local $found 1)
            (set_local $res ($MEM_VAL2_ptr $hm))
            (br $done)))
        (set_local $hm ($MEM_VAL0_ptr $hm))

        (br $loop)
      )
    )

    ;; combine found/res as hi 32/low 32 of i64
    (i64.or (i64.shl_u (i64.extend_u/i32 $found) (i64.const 32))
            (i64.extend_u/i32 $res))
  )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; function functions

  (func $FUNCTION (param $index i32) (result i32)
    ($ALLOC_SCALAR (get_global $FUNCTION_T) $index)
  )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; string functions

  (func $to_String (param $mv i32) (result i32)
    ;; skip string refcnt
    (i32.add 4 ($MalVal_val ($MalVal_index $mv) 0)))
)
