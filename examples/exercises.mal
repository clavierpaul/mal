;; These are the answers to the questions in ../docs/exercise.md.

(def! nil?   (fn* [x] (= x nil  )))
(def! true?  (fn* [x] (= x true )))
(def! false? (fn* [x] (= x false)))

(def! empty? (fn* [xs] (= 0 (count xs))))

(def! sequential? (fn* [x] (if (list? x) true (if (vector? x) true false))))

(def! >  (fn* [a b]     (< b a)            ))
(def! <= (fn* [a b] (if (< b a) false true)))
(def! >= (fn* [a b] (if (< a b) false true)))

(def! hash-map (fn* [& xs] (apply assoc {} xs)))
(def! list (fn* [& xs] xs))
(def! prn (fn* [& xs] (println (apply pr-str xs))))
(def! swap! (fn* [a f & xs] (reset! a (apply f (deref a) xs))))

(def! map
  (fn* [f xs]
    (if (empty? xs)
      ()
      (cons (f (first xs)) (map f (rest xs))))))

(def! do2 (fn* [& xs] (nth xs (- (count xs) 1))))

(defmacro! let2
  ;; Must be a macro because the first argument must not be evaluated.
  (fn* [binds form]
    (if (empty? binds)
      form
      ;;  This let* increases the readability, but the values could
      ;;  easily be replaced below.
      (let* [key  (nth binds 0)
             val  (nth binds 1)
             more (rest (rest binds))]
        `((fn* [~key] (let2 ~more ~form)) ~val)))))

(def! apply
  (let* [
    ;; (a b [c d]) -> (a b c d)
    flat_end (fn* [xs]
               (if (= 1 (count xs))
                 (first xs)        ; [c d] above
                 (cons (first xs) (flat_end (rest xs)))))
    ;; x -> 'x to protect the already-evaluated arguments.
    quote_elt (fn* [x] `(quote ~x))
    ]
    (fn* [& xs]
       (eval (map quote_elt (flat_end xs))))))
