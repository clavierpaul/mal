REM Reader library for mal in BBC BASIC

REM  ** Reader **

REM  The Reader object is implemented as an array and a mutable pointer.

DEF FNreader_peek(tokens$(), RETURN tokptr%)
=tokens$(tokptr%)

DEF FNreader_next(token$(), RETURN tokptr%)
  tokptr% += 1
=tokens$(tokptr% - 1)

DEF FNread_str(src$)
  LOCAL ntokens%, tokptr%, tokens$()
  DIM tokens$(255)
  ntokens% = FNtokenize(src$, tokens$())
  tokptr% = 0
=FNread_form(tokens$(), tokptr%)

REM  ** Tokenizer **

DEF FNtokenize(src$, tokens$())
  REM  The tokenizer is implemented explicitly as a deterministic
  REM  finite automaton.
  LOCAL p%, state%, tokstart%, tokptr%, c$, match$, action%
  LOCAL DATA

  state% = 1
  tokptr% = 0
  tokstart% = 1
  FOR p% = 1 TO LEN(src$)
    c$ = MID$(src$, p%, 1)
    REM  Convert some characters to ones that are easier to put into
    REM  DATA statements.  These substitutions are only used for
    REM  matching: the token still contains the original character.
    CASE ASC(c$) OF
      REM  These are the characters that Perl's "\s" escape matches.
      WHEN 9, 10, 11, 12, 13: c$ = " "
      REM  Double quotes are hard to put into data statements, so convert
      REM  them to "Q", first having hidden any actual "Q"
      WHEN 81: c$ = "P"
      WHEN 34: c$ = "Q"
    ENDCASE
    REM  The state table consists of a DATA statement for each current
    REM  state, which triples representing transitions.  Each triple
    REM  consists of a string of characters to match, an action, and a
    REM  next state.  A matching string of "" matches any character,
    REM  and hence marks the end of a state.

    REM  Actions are:
    REM   0: Add this character to the current token
    REM   1: Emit token; start a new token with this character
    REM   5: Emit token; skip this character

    RESTORE +state%
    REM  state 1: Initial state, or inside a bare word
    DATA " ,",5,1,          "~",1,5, "[]{}()'`^@",1,3, "Q",1,7, ";",1,11, "",0,1
    REM  state 3: Just seen the end of a token
    DATA " ,",5,1,          "~",1,5, "[]{}()'`^@",1,3, "Q",1,7, ";",1,11, "",1,1
    REM  state 5: Just seen a "~"
    DATA " ,",5,1, "@",0,3, "~",1,5, "[]{}()'`^@",1,3, "Q",1,7, ";",1,11, "",1,1
    REM  state 7: Inside a quoted string
    DATA "\",0,9, "Q",0,3, "",0,7
    REM  state 9: After a backslash in a string
    DATA "",0,7
    REM  state 11: Inside a comment
    DATA "",0,11

    REM  Find a matching transition from the current state.
    REM PRINT ;state%;"-->";
    REPEAT
      READ match$, action%, state%
      REM PRINT "[";match$;"](";action%;",";state%;")";
    UNTIL match$ = "" OR INSTR(match$, c$) > 0
    REM PRINT ;"-->";state%

    REM  Execute any actions.
    IF action% AND 1 AND p% > tokstart% THEN
      tokens$(tokptr%) = MID$(src$, tokstart%, p% - tokstart%)
      tokptr% += 1
      tokstart% = p%
    ENDIF
    IF action% AND 4 THEN tokstart% = p% + 1
  NEXT p%
  IF p% > tokstart% THEN
    tokens$(tokptr%) = MID$(src$, tokstart%, p% - tokstart%)
    tokptr% += 1
  ENDIF
=tokptr%        
