REM Types library for mal in BBC BASIC

REM  This library should be the only thing that understands the
REM  implementation of mal data types in BBC BASIC.  All other
REM  code should use routines in this library to access them.

REM  As far as other code is concerned, a mal object is just an
REM  opaque 32-bit integer, which might be a pointer, or might not.

REM  Following the 8-bit BASIC implementation, we currently have two
REM  arrays, Z%() containing most objects and S$() containing strings
REM  (referenced from Z%()).

REM  See ../basic/mem.in.bas for data representations.

DEF PROCtypes_init
  LOCAL i%
  DIM Z%(10000), S$(10000)
  FOR i% = 0 TO 15
    Z%(i%) = 0
  NEXT i%
  Z%(0) = 32: REM nil
  Z%(2) = 1+32: REM false
  Z%(4) = 1+32: Z%(5) = 1: REM true
  Z%(6) = 6+32: REM empty list
  Z%(12) = 8+32: REM empty hashmap
  next_Z% = 16
  next_S% = 0
ENDPROC

DEF FNtype_of(val%)
=Z%(val%) AND 31

DEF FNmalloc(size%)
  LOCAL val%
  val% = next_Z%
  next_Z% += size%
=val%

REM ** Nil **

DEF FNis_nil(val%)
=FNtype_of(val%) = 0

DEF FNnil
=0

REM ** Boolean **

DEF FNis_boolean(val%)
=FNtype_of(val%) = 1

DEF FNalloc_boolean(bval%)
  IF bval% THEN =4
=2

DEF FNunbox_boolean(val%)
  IF NOT FNis_boolean(val%) THEN ERROR &40E80911, "Not a boolean"
  IF Z%(val% + 1) THEN =TRUE
=FALSE

REM ** Integers **

DEF FNis_int(val%)
=FNtype_of(val%) = 2

DEF FNalloc_int(ival%)
  LOCAL val%
  val% = FNmalloc(2)
  Z%(val%) = 2+32
  Z%(val% + 1) = ival%
=val%

DEF FNunbox_int(val%)
  IF NOT FNis_int(val%) THEN ERROR &40E80912, "Not an integer"
=Z%(val% + 1)

REM ** Symbols **

DEF FNis_symbol(val%)
=FNtype_of(val%) = 5

DEF FNalloc_symbol(sval$)
  LOCAL s%
  s% = next_S%
  next_S% += 1
  S$(s%) = sval$
  val% = FNmalloc(2)
  Z%(val%) = 5+32
  Z%(val% + 1) = s%
=val%

DEF FNunbox_symbol(val%)
  IF NOT FNis_symbol(val%) THEN ERROR &40E80915, "Not a symbol"
=S$(Z%(val% + 1))

REM ** Lists **

DEF FNempty
=6

DEF FNalloc_pair(car%, cdr%)
  LOCAL val%
  val% = FNmalloc(3)
  Z%(val% + 0) = 6+32
  Z%(val% + 2) = car%
  Z%(val% + 1) = cdr%
=val%

DEF FNis_empty(val%)
=val% = FNempty

DEF FNis_list(val%)
=FNtype_of(val%) = 6

DEF FNlist_car(val%)
  IF NOT FNis_list(val%) THEN ERROR &40E80916, "Can't get car of non-list"
  IF Z%(val% + 1) = 0 THEN ERROR &40E80920, "Can't get car of empty list"
=Z%(val% + 2)

DEF FNlist_cdr(val%)
  IF NOT FNis_list(val%) THEN ERROR &40E80916, "Can't get cdr of non-list"
  IF Z%(val% + 1) = 0 THEN ERROR &40E80920, "Can't get cdr of empty list"
=Z%(val% + 1)

DEF FNlist_len(val%)
  LOCAL i%
  WHILE NOT FNis_empty(val%)
    val% = FNlist_cdr(val%)
    i% += 1
  ENDWHILE
= i%

DEF PROClist_to_array(val%, a%())
  REM  a%() must already be correctly dimensioned.
  LOCAL i%
  WHILE NOT FNis_empty(val%)
    a%(i%) = FNlist_car(val%)
    val% = FNlist_cdr(val%)
    i% += 1
  ENDWHILE
ENDPROC

REM ** Core functions **

DEF FNis_corefn(val%)
=FNtype_of(val%) = 9

DEF FNalloc_corefn(fn%)
  LOCAL val%
  val% = FNmalloc(2)
  Z%(val% + 0) = 32 + 9
  Z%(val% + 1) = fn%
=val%

DEF FNunbox_corefn(val%)
  IF NOT FNis_corefn(val%) THEN ERROR &40E80919, "Not a core function"
=Z%(val% + 1)

REM ** Hashmaps **

REM  To defer implementing mal strings for a bit, hashmap keys are
REM  currently BASIC strings rather than arbitrary values.

DEF FNempty_hashmap
=12

DEF FNalloc_hashmap_entry(key$, val%, next%)
  LOCAL entry%
  LOCAL s%
  s% = next_S%
  next_S% += 1
  S$(s%) = key$
  entry% = FNmalloc(4)
  Z%(entry% + 0) = 32 + 8
  Z%(entry% + 1) = next%
  Z%(entry% + 2) = s%
  Z%(entry% + 3) = val%
=entry%

DEF FNis_hashmap(val%)
=FNtype_of(val%) = 8

DEF FNhashmap_get(map%, key$)
  IF NOT FNis_hashmap(map%) THEN ERROR &40E80918, "Can't get item from a non-hashmap"
  IF map% = FNempty_hashmap THEN =FNnil
  IF S$(Z%(map% + 2)) = key$ THEN =Z%(map% + 3)
=FNhashmap_get(Z%(map% + 1), key$)

REM ** Environments **

DEF FNis_environment(val%)
=FNtype_of(val%) = 13

DEF FNalloc_environment(outer%)
  LOCAL val%
  val% = FNmalloc(3)
  Z%(val% + 0) = 32 + 13
  Z%(val% + 1) = FNempty_hashmap
  Z%(val% + 2) = outer%
=val%

DEF FNenvironment_data(val%)
  IF NOT FNis_environment(val%) THEN ERROR &40E8091D, "Not an environment"
=Z%(val% + 1)

DEF PROCenvironment_set_data(val%, data%)
  IF NOT FNis_environment(val%) THEN ERROR &40E8091D, "Not an environment"
  Z%(val% + 1) = data%
ENDPROC

DEF FNenvironment_outer(val%)
  IF NOT FNis_environment(val%) THEN ERROR &40E8091D, "Not an environment"
=Z%(val% + 2)
