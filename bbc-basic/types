REM > types library for mal in BBC BASIC

REM  This library should be the only thing that understands the
REM  implementation of mal data types in BBC BASIC.  All other
REM  code should use routines in this library to access them.

REM  As far as other code is concerned, a mal object is just an
REM  opaque 32-bit integer, which might be a pointer, or might not.

REM  Following the 8-bit BASIC implementation, we currently have two
REM  arrays, Z%() containing most objects and S$() containing strings
REM  (referenced from Z%()).  Unlike that implementation, we use a
REM  two-dimensional array where each object is a whole row.  This
REM  is inefficient but should make memory management simpler.

REM  S%() holds reference counts for the strings in S$().  At present
REM  these are all 0 or 1.

REM  Z%(x,0) holds the type of an object and other small amounts of
REM  information.  The bottom 4 bits indicate the semantics of the other
REM  fields:

REM  &01 : Z%(x,1) is a pointer into Z%()
REM  &02 : Z%(x,2) is a pointer into Z%()
REM  &04 : Z%(x,3) is a pointer into Z%()
REM  &08 : Z%(x,1) is a pointer into S$()

REM  sS%() is a shadow stack, used to keep track of which mal values might
REM  be referenced from local variables at a given depth of the BASIC call
REM  stack.  It grows upwards.  sSP% points to the first unused word.  sFP%
REM  points to the start of the current shadow stack frame.  The first word
REM  of each shadow stack frame is the saved value of sFP%.  The rest are
REM  mal values.

REM  Types are:
REM  &00  nil
REM  &10  boolean
REM  &20  integer
REM  &30  core function
REM  &40  empty hash-map
REM  &01  atom
REM  &11  free block
REM  &03  list (each object is a cons cell)
REM  &13  environment
REM  &23  hash-map internal node
REM  &07  mal function
REM  &08  string/keyword
REM  &18  symbol
REM  &0A  hash-map leaf node

REM  Formats of individual objects are defined below.

DEF PROCtypes_init
  REM  Arbitrarily use half of BASIC's heap as the mal heap, with a bit
  REM  more for strings.  Each heap entry is sixteen bytes.
  DIM Z%((HIMEM-LOMEM)/32,3)
  DIM S$((HIMEM-LOMEM)/64), S%((HIMEM-LOMEM)/64)
  DIM sS%((HIMEM-LOMEM)/64)
  Z%(1,0) = &10 : REM false
  Z%(2,0) = &10 : Z%(2,1) = TRUE : REM true
  Z%(3,0) = &03 : REM empty list
  Z%(4,0) = &83 : REM empty vector
  Z%(5,0) = &40:  REM empty hashmap
  next_Z% = 6
  next_S% = 0
  sSP% = 1
  sFP% = 0
  F% = 0
  SF% = 0
ENDPROC

DEF FNtype_of(val%)
=Z%(val%,0) AND &3F

DEF PROCgc_enter
  REM PRINT ;sFP%;
  sS%(sSP%) = sFP%
  sFP% = sSP%
  sSP% += 1
  REM PRINT " >>> ";sFP%
ENDPROC

REM  FNgc_save is equivalent to PROCgc_enter except that it returns a
REM  value that can be passed to PROCgc_restore to pop all the stack
REM  frames back to (and including) the one pushed by FNgc_save.
DEF FNgc_save
  PROCgc_enter
=sFP%

DEF PROCgc_exit
  REM PRINT ;sS%(sFP%);" <<< ";sFP%
  sSP% = sFP%
  sFP% = sS%(sFP%)
ENDPROC

DEF PROCgc_restore(oldFP%)
  sFP% = oldFP%
  REM PRINT "!!! FP reset"
  PROCgc_exit
ENDPROC

DEF FNref_local(val%)
  sS%(sSP%) = val%
  sSP% += 1
=val%

DEF FNgc_exit(val%)
  PROCgc_exit
=FNref_local(val%)

DEF FNgc_restore(oldFP%, val%)
  PROCgc_restore(oldFP%)
=FNref_local(val%)

DEF PROCgc_keep_only2(val1%, val2%)
  PROCgc_exit
  PROCgc_enter
  val1% = FNref_local(val1%)
  val2% = FNref_local(val2%)
ENDPROC

DEF FNmalloc(type%)
  LOCAL val%
  REM  If the heap is full, collect garbage first.
  IF F% = 0 AND next_Z% > DIM(Z%(),1) THEN PROCgc
  IF F% <> 0 THEN
    val% = F%
    F% = Z%(val%,1)
  ELSE
    val% = next_Z%
    next_Z% += 1
  ENDIF
  Z%(val%,0) = type%
=FNref_local(val%)

DEF FNsalloc(s$)
  LOCAL val%
  IF SF% <> 0 THEN
    val% = SF%
    SF% = S%(val%)
  ELSE
    val% = next_S%
    next_S% += 1
  ENDIF
  S$(val%) = s$
=val%

DEF PROCfree(val%)
  IF (Z%(val%,0) AND &08) THEN PROCsfree(Z%(val%,1))
  Z%(val%,0) = &11
  Z%(val%,1) = F%
  Z%(val%,2) = 0
  Z%(val%,3) = 0
  F% = val%
ENDPROC

DEF PROCsfree(val%)
  S$(val%) = ""
  S%(val%) = SF%
  SF% = val%
ENDPROC

DEF PROCgc
  REM PRINT "** START GC **"
  PROCgc_markall
  PROCgc_sweep
  REM PRINT "** FINISH GC **"
ENDPROC

DEF PROCgc_markall
  LOCAL sp%, fp%
  fp% = sFP%
  REM PRINT ">>marking...";
  FOR sp% = sSP% - 1 TO 0 STEP -1
    IF sp% = fp% THEN
      fp% = sS%(sp%)
      REM PRINT " / ";
    ELSE PROCgc_mark(sS%(sp%))
    ENDIF
  NEXT sp%
  REM PRINT
ENDPROC

DEF PROCgc_mark(val%)
  IF (Z%(val%,0) AND &100) = 0 THEN
    REM PRINT " ";val%;
    Z%(val%,0) += &100
    IF (Z%(val%,0) AND &01) THEN PROCgc_mark(Z%(val%,1))
    IF (Z%(val%,0) AND &02) THEN PROCgc_mark(Z%(val%,2))
    IF (Z%(val%,0) AND &04) THEN PROCgc_mark(Z%(val%,3))
  ENDIF
ENDPROC

DEF PROCgc_sweep
  LOCAL val%
  REM PRINT ">>sweeping ...";
  FOR val% = 6 TO next_Z% - 1
    IF FNtype_of(val%) <> &11 AND (Z%(val%,0) AND &100) = 0 THEN
      REM PRINT " ";val%;
      PROCfree(val%)
    ELSE
      Z%(val%,0) -= &100
    ENDIF
  NEXT val%
  REM PRINT
ENDPROC

REM ** Nil **

DEF FNis_nil(val%)
=FNtype_of(val%) = 0

DEF FNnil
=0

REM ** Boolean **

REM  Z%(x,1) = TRUE or FALSE

DEF FNis_boolean(val%)
=FNtype_of(val%) = &10

DEF FNalloc_boolean(bval%)
  IF bval% THEN =2
=1

DEF FNunbox_boolean(val%)
  IF NOT FNis_boolean(val%) THEN ERROR &40E80911, "Not a boolean"
=Z%(val%,1)

DEF FNis_truish(val%)
  IF FNis_nil(val%) THEN =FALSE
  IF FNis_boolean(val%) THEN =FNunbox_boolean(val%)
=TRUE

REM ** Integers **

REM  Z%(x,1) = integer value

DEF FNis_int(val%)
=FNtype_of(val%) = &20

DEF FNalloc_int(ival%)
  LOCAL val%
  val% = FNmalloc(&20)
  Z%(val%,1) = ival%
=val%

DEF FNunbox_int(val%)
  IF NOT FNis_int(val%) THEN ERROR &40E80912, "Not an integer"
=Z%(val%,1)

REM ** Strings and keywords **

REM  A keyword is a string with first character CHR$(127).

DEF FNis_string(val%)
=FNtype_of(val%) = &08

DEF FNalloc_string(sval$)
  LOCAL val%
  val% = FNmalloc(&08)
  Z%(val%,1) = FNsalloc(sval$)
=val%

DEF FNunbox_string(val%)
  IF NOT FNis_string(val%) THEN ERROR &40E80914, "Not a string"
=S$(Z%(val%,1))

REM ** Symbols **

REM  Z%(x,1) = index in S$() of the value of the symbol

DEF FNis_symbol(val%)
=FNtype_of(val%) = &18

DEF FNalloc_symbol(sval$)
  LOCAL val%
  val% = FNmalloc(&18)
  Z%(val%,1) = FNsalloc(sval$)
=val%

DEF FNunbox_symbol(val%)
  IF NOT FNis_symbol(val%) THEN ERROR &40E80915, "Not a symbol"
=S$(Z%(val%,1))

REM ** Lists and vectors **

REM  Lists and vectors are both represented as linked lists: the only
REM  difference is in the state of the is_vector flag in the head cell
REM  of the list.  Note that this means that the tail of a list may be
REM  a vector, and vice versa.  FNas_list and FNas_vector can be used
REM  to convert a sequence to a particular type as necessary.

REM  Z%(x,0) AND &80 = is_vector flag
REM  Z%(x,1) = index in Z%() of next pair
REM  Z%(x,2) = index in Z%() of first element

REM  The empty list is a distinguished value, which happens to have
REM  both elements nil.

DEF FNempty
=3

DEF FNempty_vector
=4

DEF FNalloc_pair(car%, cdr%)
  LOCAL val%
  val% = FNmalloc(&03)
  Z%(val%,2) = car%
  Z%(val%,1) = cdr%
=val%

DEF FNalloc_vector_pair(car%, cdr%)
  LOCAL val%
  val% = FNalloc_pair(car%, cdr%)
  Z%(val%,0) = Z%(val%,0) OR &80
=val%

DEF FNis_empty(val%)
=val% = FNempty OR val% = FNempty_vector

DEF FNis_seq(val%)
=FNtype_of(val%) = &03

DEF FNis_list(val%)
=FNtype_of(val%) = &03 AND (Z%(val%, 0) AND &80) = &00

DEF FNis_vector(val%)
=FNtype_of(val%) = &03 AND (Z%(val%, 0) AND &80) = &80

DEF FNas_list(val%)
  IF FNis_list(val%) THEN =val%
  IF FNis_empty(val%) THEN =FNempty
=FNalloc_pair(FNfirst(val%), FNrest(val%))

DEF FNas_vector(val%)
  IF FNis_vector(val%) THEN =val%
  IF FNis_empty(val%) THEN =FNempty_vector
=FNalloc_vector_pair(FNfirst(val%), FNrest(val%))

DEF FNfirst(val%)
  IF NOT FNis_seq(val%) THEN ERROR &40E80916, "Can't get car of non-sequence"
  IF Z%(val%,1) = 0 THEN ERROR &40E80920, "Can't get car of empty sequence"
=FNref_local(Z%(val%,2))

DEF FNrest(val%)
  IF NOT FNis_seq(val%) THEN ERROR &40E80916, "Can't get cdr of non-sequence"
  IF Z%(val%,1) = 0 THEN ERROR &40E80920, "Can't get cdr of empty sequence"
=FNref_local(Z%(val%,1))

DEF FNalloc_list2(val0%, val1%)
  =FNalloc_pair(val0%, FNalloc_pair(val1%, FNempty))

DEF FNalloc_list3(val0%, val1%, val2%)
  =FNalloc_pair(val0%, FNalloc_pair(val1%, FNalloc_pair(val2%, FNempty)))

DEF FNcount(val%)
  LOCAL i%
  WHILE NOT FNis_empty(val%)
    val% = FNrest(val%)
    i% += 1
  ENDWHILE
= i%

DEF FNnth(val%, n%)
  WHILE n% > 0
    IF FNis_empty(val%) THEN ERROR &40E80923, "Subscript out of range"
    val% = FNrest(val%)
    n% -= 1
  ENDWHILE
  IF FNis_empty(val%) THEN ERROR &40E80923, "Subscript out of range"
=FNfirst(val%)

DEF PROClist_to_array(val%, a%())
  REM  a%() must already be correctly dimensioned.
  LOCAL i%
  WHILE NOT FNis_empty(val%)
    a%(i%) = FNref_local(FNfirst(val%))
    val% = FNrest(val%)
    i% += 1
  ENDWHILE
ENDPROC

DEF FNarray_to_list(a%())
  LOCAL i%, val%
  PROCgc_enter
  val% = FNempty
  IF DIM(a%(), 1) = 0 THEN =val%
  FOR i% = DIM(a%(), 1) - 1 TO 0 STEP -1
    val% = FNalloc_pair(a%(i%), val%)
  NEXT i%
=FNgc_exit(val%)

REM ** Core functions **

REM  Z%(x,1) = index of function in FNcore_call

DEF FNis_corefn(val%)
=FNtype_of(val%) = &30

DEF FNalloc_corefn(fn%)
  LOCAL val%
  val% = FNmalloc(&30)
  Z%(val%,1) = fn%
=val%

DEF FNunbox_corefn(val%)
  IF NOT FNis_corefn(val%) THEN ERROR &40E80919, "Not a core function"
=Z%(val%,1)

REM ** Hash-maps **

REM  Hash-maps are represented as a PATRICIA tree.
REM  An internal node has:
REM  Z%(x,0) >> 16 = next bit of key to check
REM  Z%(x,1) = index in Z%() of left child (if next bit of key is 0)
REM  Z%(x,2) = index in Z%() of right child (if next bit of key is 1)

REM  A leaf node has
REM  Z%(x,1) = index in S$() of key
REM  Z%(x,2) = index in Z%() of value

REM  The empty hash-map is a special value containing no data.

DEF FNempty_hashmap
=5

DEF FNis_empty_hashmap(val%)
=val% = FNempty_hashmap

DEF FNhashmap_alloc_leaf(key$, val%)
  LOCAL entry%
  entry% = FNmalloc(&0A)
  Z%(entry%,1) = FNsalloc(key$)
  Z%(entry%,2) = val%
=entry%  

DEF FNis_hashmap(val%)
  LOCAL t%
  t% = FNtype_of(val%)
=t% = &23 OR t% = &0A OR t% = &40

DEF FNhashmap_set(map%, key$, val%)
  IF FNis_empty_hashmap(map%) THEN =FNhashmap_alloc_leaf(key$, val%)
ERROR &40E809FF, "More that one element in hash-map!"

DEF FNhashmap_get(map%, key$)
  IF NOT FNis_hashmap(map%) THEN ERROR &40E80918, "Can't get item from a non-hashmap"
  IF FNis_empty_hashmap(map%) THEN =FNnil
  IF FNtype_of(map%) = &0A THEN
    IF S$(Z%(map%,1)) = key$ THEN =FNref_local(Z%(map%,2)) ELSE =FNnil
  ENDIF
=FNnil

DEF FNhashmap_contains(map%, key$)
  IF NOT FNis_hashmap(map%) THEN ERROR &40E80918, "Can't get item from a non-hashmap"
  IF FNis_empty_hashmap(map%) THEN =FALSE
  IF FNtype_of(map%) = &0A THEN
    IF S$(Z%(map%,1)) = key$ THEN =TRUE ELSE =FALSE
  ENDIF
=FALSE

DEF FNhashmap_keys(map%)
  IF FNis_empty_hashmap(map%) THEN =FNempty
=FNalloc_pair(FNalloc_string(S$(Z%(map%,1))), FNempty)

REM ** Functions **

REM  Z%(x,0) AND &80 = is_macro flag
REM  Z%(x,1) = index in Z%() of ast
REM  Z%(x,2) = index in Z%() of params
REM  Z%(x,3) = index in Z%() of env

DEF FNis_fn(val%)
=FNtype_of(val%) = &07

DEF FNis_nonmacro_fn(val%)
=FNtype_of(val%) = &07 AND (Z%(val%, 0) AND &80) = &00

DEF FNis_macro(val%)
=FNtype_of(val%) = &07 AND (Z%(val%, 0) AND &80) = &80

DEF FNalloc_fn(ast%, params%, env%)
  LOCAL val%
  val% = FNmalloc(&07)
  Z%(val%,1) = ast%
  Z%(val%,2) = params%
  Z%(val%,3) = env%
=val%

DEF PROCmake_macro(val%)
  IF NOT FNis_fn(val%) THEN ERROR &40E8091A, "Not a function"
  Z%(val%, 0) = Z%(val%, 0) OR &80
ENDPROC

DEF FNfn_ast(val%)
  IF NOT FNis_fn(val%) THEN ERROR &40E8091A, "Not a function"
=FNref_local(Z%(val%,1))

DEF FNfn_params(val%)
  IF NOT FNis_fn(val%) THEN ERROR &40E8091A, "Not a function"
=FNref_local(Z%(val%,2))

DEF FNfn_env(val%)
  IF NOT FNis_fn(val%) THEN ERROR &40E8091A, "Not a function"
=FNref_local(Z%(val%,3))

REM ** Atoms **

REM Z%(x,1) = index in Z% of current referent

DEF FNis_atom(val%)
=FNtype_of(val%) = &01

DEF FNalloc_atom(contents%)
  LOCAL val%
  val% = FNmalloc(&01)
  Z%(val%,1) = contents%
=val%

DEF FNatom_deref(val%)
=FNref_local(Z%(val%,1))

DEF PROCatom_reset(val%, contents%)
  Z%(val%,1) = contents%
ENDPROC

REM ** Environments **

REM  Z%(x,1) = index in Z% of hash-map
REM  Z%(x,2) = index in Z% of outer environment

DEF FNis_environment(val%)
=FNtype_of(val%) = &13

DEF FNalloc_environment(outer%)
  LOCAL val%
  val% = FNmalloc(&13)
  Z%(val%,1) = FNempty_hashmap
  Z%(val%,2) = outer%
=val%

DEF FNenvironment_data(val%)
  IF NOT FNis_environment(val%) THEN ERROR &40E8091D, "Not an environment"
=FNref_local(Z%(val%,1))

DEF PROCenvironment_set_data(val%, data%)
  IF NOT FNis_environment(val%) THEN ERROR &40E8091D, "Not an environment"
  Z%(val%,1) = data%
ENDPROC

DEF FNenvironment_outer(val%)
  IF NOT FNis_environment(val%) THEN ERROR &40E8091D, "Not an environment"
=FNref_local(Z%(val%,2))

REM Local Variables:
REM indent-tabs-mode: nil
REM End:
