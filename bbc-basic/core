REM > core function library for mal in BBC BASIC

REM  BBC BASIC doesn't have function pointers.  There are essentially
REM  two ways to work around this.  One is to use the BASIC EVAL function,
REM  constructing a string that will call an arbitrary function with the
REM  specified arguments.  The other is to us a big CASE statement.
REM  Following the suggestion in Hints.md, this code takes the latter
REM  approach.

DEF PROCcore_ns
  RESTORE +0
  REM  The actual DATA statements are embedded in the dispatch table below.
ENDPROC

REM  Call a core function, taking the function number and an array of mal
REM  objects to pass as arguments.
DEF FNcore_call(fn%, args%())
  CASE fn% OF
    DATA +, 0
    WHEN 0
      PROCcore_assert_args("ii", "+", args%())
      =FNalloc_int(FNunbox_int(args%(0)) + FNunbox_int(args%(1)))
    DATA -, 1
    WHEN 1
      PROCcore_assert_args("ii", "-", args%())
      =FNalloc_int(FNunbox_int(args%(0)) - FNunbox_int(args%(1)))
    DATA *, 2
    WHEN 2
      PROCcore_assert_args("ii", "*", args%())
      =FNalloc_int(FNunbox_int(args%(0)) * FNunbox_int(args%(1)))
    DATA /, 3
    WHEN 3
      PROCcore_assert_args("ii", "/", args%())
      =FNalloc_int(FNunbox_int(args%(0)) DIV FNunbox_int(args%(1)))
    DATA list, 5
    WHEN 5
      =FNarray_to_list(args%())
    DATA list?, 6
    WHEN 6
      PROCcore_assert_args("?", "list?", args%())
      =FNalloc_boolean(FNis_list(args%(0)))
    DATA empty?, 7
    WHEN 7
      PROCcore_assert_args("l", "empty?", args%())
      =FNalloc_boolean(FNis_empty(args%(0)))
    DATA count, 8
    WHEN 8
      PROCcore_assert_args("C", "count", args%())
      IF FNis_nil(args%(0)) THEN =FNalloc_int(0)
      =FNalloc_int(FNlist_len(args%(0)))
    DATA =, 9
    WHEN 9
      PROCcore_assert_args("??", "=", args%())
      =FNalloc_boolean(FNcore_equal(args%(0), args%(1)))
    DATA <, 10
    WHEN 10
      PROCcore_assert_args("ii", "<", args%())
      =FNalloc_boolean(FNunbox_int(args%(0)) < FNunbox_int(args%(1)))
    DATA <=, 11
    WHEN 11
      PROCcore_assert_args("ii", "<=", args%())
      =FNalloc_boolean(FNunbox_int(args%(0)) <= FNunbox_int(args%(1)))
    DATA >, 12
    WHEN 12
      PROCcore_assert_args("ii", ">", args%())
      =FNalloc_boolean(FNunbox_int(args%(0)) > FNunbox_int(args%(1)))
    DATA >=, 13
    WHEN 13
      PROCcore_assert_args("ii", ">=", args%())
      =FNalloc_boolean(FNunbox_int(args%(0)) >= FNunbox_int(args%(1)))
    DATA read-string, 14
    WHEN 14
      PROCcore_assert_args("s", "read-string", args%())
      =FNread_str(FNunbox_string(args%(0)))
    DATA slurp, 15
    WHEN 15
      PROCcore_assert_args("s", "slurp", args%())
      =FNalloc_string(FNcore_slurp(FNunbox_string(args%(0))))
    DATA eval, 16
    WHEN 16
      PROCcore_assert_args("?", "eval", args%())
      =FNEVAL(args%(0), repl_env%)
    DATA pr-str, 17
    WHEN 17
      =FNalloc_string(FNcore_print(TRUE, " ", args%()))
    DATA str, 18
    WHEN 18
      =FNalloc_string(FNcore_print(FALSE, "", args%()))
    DATA prn, 4
    WHEN 4
      PROCmalio_println(FNcore_print(TRUE, " ", args%()))
      =FNnil
    DATA println, 19
    WHEN 19
      PROCmalio_println(FNcore_print(FALSE, " ", args%()))
      =FNnil
    DATA atom, 20
    WHEN 20
      PROCcore_assert_args("?", "atom", args%())
      =FNalloc_atom(args%(0))
    DATA atom?, 21
    WHEN 21
      PROCcore_assert_args("?", "atom?", args%())
      =FNalloc_boolean(FNis_atom(args%(0)))
    DATA deref, 22
    WHEN 22
      PROCcore_assert_args("a", "deref", args%())
      =FNatom_deref(args%(0))
    DATA reset!, 23
    WHEN 23
      PROCcore_assert_args("a?", "reset!", args%())
      PROCatom_reset(args%(0), args%(1))
      =args%(1)
    DATA "", -1
  ENDCASE
ERROR &40E809F1, "Call to non-existent core function"

DEF PROCcore_assert_args(spec$, fn$, args%())
  REM  Check that a core function is being provided with the correct
  REM  number and type of arguments.  spec$ is the argument specification
  REM  as a string.  Each character represents an argument:
  REM  "i" - Must be an integer
  REM  "s" - Must be a string
  REM  "l" - Must be a list
  REM  "a" - Must be an atom
  REM  "C" - Must be 'count'able
  REM  "?" - Any single argument

  LOCAL i%

  IF DIM(args%(), 1) <> LEN(spec$) THEN
    ERROR &40E80921, "Core function '"+fn$+"' requires "+STR$(LEN(spec$))+" arguments"
  ENDIF
  FOR i% = 1 TO LEN(spec$)
    CASE MID$(spec$, i%, 1) OF
      WHEN "i"
        IF NOT FNis_int(args%(i% - 1)) THEN
          ERROR &40E80911, "Argument "+STR$(i%)+" to core function '"+fn$+"' must be an integer"
        ENDIF
      WHEN "s"
        IF NOT FNis_string(args%(i% - 1)) THEN
          ERROR &40E80914, "Argument "+STR$(i%)+" to core function '"+fn$+"' must be a list"
        ENDIF
      WHEN "l"
        IF NOT FNis_list(args%(i% - 1)) THEN
          ERROR &40E80916, "Argument "+STR$(i%)+" to core function '"+fn$+"' must be a list"
        ENDIF
      WHEN "a"
        IF NOT FNis_atom(args%(i% - 1)) THEN
          ERROR &40E8091C, "Argument "+STR$(i%)+" to core function '"+fn$+"' must be an atom"
        ENDIF
      WHEN "C"
        IF NOT FNis_list(args%(i% - 1)) AND NOT FNis_nil(args%(i% - 1)) THEN
          ERROR &40E8091F, "Argument "+STR$(i%)+" to core function '"+fn$+"' must be a countable value"
        ENDIF
      WHEN "?"
        REM  Nothing to do here
    ENDCASE
  NEXT i%
ENDPROC

REM  Innards of the '=' function.
DEF FNcore_equal(a%, b%)
  IF a% = b% THEN =TRUE
  IF FNis_int(a%) AND FNis_int(b%) THEN =FNunbox_int(a%) = FNunbox_int(b%)
  IF FNis_symbol(a%) AND FNis_symbol(b%) THEN
    =FNunbox_symbol(a%) = FNunbox_symbol(b%)
  ENDIF
  IF FNis_string(a%) AND FNis_string(b%) THEN
    =FNunbox_string(a%) = FNunbox_string(b%)
  ENDIF
  IF FNis_list(a%) AND FNis_list(b%) THEN
    IF FNis_empty(a%) AND FNis_empty(b%) THEN =TRUE
    IF FNis_empty(a%) <> FNis_empty(b%) THEN =FALSE
    IF NOT FNcore_equal(FNlist_car(a%), FNlist_car(b%)) THEN =FALSE
    =FNcore_equal(FNlist_cdr(a%), FNlist_cdr(b%))
  ENDIF
=FALSE

REM  Innards of the 'slurp' function.
DEF FNcore_slurp(file$)
  LOCAL f%, out$
  f% = OPENIN(file$)
  IF f% = 0 THEN ERROR &40E80940, "File '"+file$+"' not found"
  WHILE NOT EOF#f%
    out$ += GET$#f%
    REM  GET$# doesn't include a trailing newline.
    out$ += CHR$(10)
  ENDWHILE
  CLOSE#f%
=out$

REM  General-purpose printing function
DEF FNcore_print(print_readably%, sep$, args%())
  LOCAL out$, i%
  IF DIM(args%(),1) = 0 THEN =""
  FOR i% = 0 TO DIM(args%(),1) - 1
    out$ += FNpr_str(args%(i%), print_readably%)
    IF i% < DIM(args%(),1) - 1 THEN out$ += sep$
  NEXT i%
=out$

REM Local Variables:
REM indent-tabs-mode: nil
REM End:
